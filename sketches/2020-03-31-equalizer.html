<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1 user-scalable=0"
    />
    <style>
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
    <script src="/node_modules/p5/lib/p5.min.js"></script>
    <script src="/node_modules/p5/lib/addons/p5.sound.min.js"></script>
    <script src="/node_modules/dat.gui/build/dat.gui.min.js"></script>
    <script>
      const log = console.log.bind(console);

      const CANVAS_WIDTH = window.innerWidth;
      const CANVAS_HEIGHT = window.innerHeight;
      
      // Options
      let opts = {
        lines: 30,
        width: 250,
        height: 400,
        strokeWeight: 2,
        amplitude: 40,
        spectrumRange: 800,
      };

      let sound;

      function preload(){
        // sound = loadSound('./audio/toms-diner.mp3');
        sound = loadSound('./audio/warsaw.mp3');
      }

      function setup() {
        let gui = new dat.GUI();
        gui.add(opts, 'lines', 0, 100);
        gui.add(opts, 'width', 0, 1000);
        gui.add(opts, 'height', 0, 1000);
        gui.add(opts, 'strokeWeight', 0, 20);
        gui.add(opts, 'amplitude', 0, 100);
        gui.add(opts, 'spectrumRange', 0, 1024);

        let canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
        canvas.mouseClicked(togglePlay);
        
        fft = new p5.FFT();
        sound.amp(0.5);
        // sound.play();
        // noLoop();
      }


      // TODO: Try on white, and shrink down
      
      function draw() {
        background(0);
        stroke(255);
        strokeWeight(opts.strokeWeight);
        noFill();


        // Measure amplitude
        // returns Array of 1024 integers between 0 and 255
        let spectrum = fft.analyze();

        let segments = Math.floor(opts.spectrumRange / opts.lines);
        let segmentLength = opts.width / segments;
        
        push();

        translate(
          (CANVAS_WIDTH / 2) - (opts.width / 2),
          (CANVAS_HEIGHT / 2) - (opts.height / 2)
        );

        let gap = opts.height / opts.lines;

        // Draw top to bottom
        // TODO: Add black fill
        for (let i = 0; i < opts.lines; i++) {
          beginShape();

          for (let j = 0; j < segments; j++) {
            let amp = spectrum[(i * segments) + j];
            amp = map(amp, 0, 255, 0, opts.amplitude)
            curveVertex(j * segmentLength, (i * gap) - amp);
          }
          endShape();

          // line(
          //   0, i * gap,
          //   opts.width, i * gap
          // );
        }
        pop()

        // noStroke();
        // fill(255, 0, 255);

        // for (let i = 0; i< spectrum.length; i++){
        //   let x = map(i, 0, spectrum.length, 0, CANVAS_WIDTH);
        //   let h = -CANVAS_HEIGHT + map(spectrum[i], 0, 255, CANVAS_HEIGHT, 0);
        //   rect(x, CANVAS_HEIGHT, CANVAS_WIDTH / spectrum.length, h )
        // }

        // let waveform = fft.waveform();
        // noFill();
        // beginShape();
        // stroke(20);
        // for (let i = 0; i < waveform.length; i++){
        //   let x = map(i, 0, waveform.length, 0, width);
        //   let y = map( waveform[i], -1, 1, 0, height);
        //   vertex(x,y);
        // }
        // endShape();

      }

      function togglePlay() {
        if (sound.isPlaying()) {
          sound.pause();
        } else {
          sound.loop();
        }
      }
    </script>
  </head>
  <body></body>
</html>
